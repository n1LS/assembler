<html>

<head>
    <meta charset="utf-8" />
    <style>
        * {
            background:black;
            border: 0px;
            margin: 0px;
            padding: 0px;
        }

       #display {
            width: 100%;
            height: 100%;
            background: black;
        }
    </style>

    <script src="rc-core.js"></script>
    <script src="rc-math.js"></script>
    <script src="rc-constants.js"></script>
    <script src="rc-address-modes.js"></script>
    <script src="rc-preprocessor.js"></script>
    <script src="rc-assembler.js"></script>
    <script src="rc-classes.js"></script>
    <script src="rc-instruction.js"></script>
    <script src="rc-instruction-set.js"></script>

    <script src="canvas-draw.js"></script>
    <script src="canvas-font.js"></script>

    <script>

        var core
        var timer
        var buttons
        var scale = 1
        var cycles = 1

        function run() {
            stop()
            timer = setInterval(run_cycle, 20)
        }

        function stop() {
            clearInterval(timer)
        }

        function run_cycle() {
            for (var c = 0; c < cycles; c++) {
                if (!core.step()) {
                    stop();
                    break;
                }
            }

            draw()
        }

        function toggle_boost() {
            cycles = cycles == 1 ? 1000 : 1
        }        

        var memory = new Array(kCORE_MEMORY_SIZE)

        const process_colors = [kDarkestGrey, kProcess1, kProcess2]
        const process_colors_low = [kDarkestGrey, kProcessLow1, kProcessLow2]
        const process_text_colors = [kGrey, kProcess1Text, kProcess2Text]

        function hash(instruction) {
            return `${instruction.opcode}${instruction.read_flag}${instruction.write_flag}${instruction.execution_flag}${instruction.a.mode}${instruction.a.value}${instruction.b.mode}${instruction.b.value}`
        }

        function draw_memory(dx, dy, w, h) {
            const optimize = false

            function location(index) {
                return { x: index % cols, y: Math.floor(index / cols) }
            }

            const size = row_height
            const cols = Math.floor(w / size)
            const rows = Math.floor(h / size)

            draw_translate_to(dx, dy)

            const numEntries = cols * rows

            for (var i = 0; i < numEntries; i++) {
                const idx = i % kCORE_MEMORY_SIZE
                const instruction = core.ram.memory[idx]
                const i_hash = hash(instruction)

                if (i >= kCORE_MEMORY_SIZE && optimize) {
                    break;
                }

                if (i_hash == memory[i]) {
                    continue;
                }

                memory[i] = i_hash

                var l = location(i)
                const x = l.x * size
                const y = l.y * size

                draw_triangles(x, y, size, size, process_colors_low[instruction.read_flag + 1], process_colors_low[instruction.write_flag + 1])
                
                const symbol = {
                    'MOV': 0, 'DAT': 1, 'JMP': 2, 'NOP': 3, 'SPL': 4, 
                    'ADD': 5, 'SUB': 6, 'JMZ': 7, 'JNZ': 8, 'CMP': 9,
                    'DJN': 10,
                }[instruction.op.name]

                draw_symbol(x, y, symbol, process_text_colors[instruction.execution_flag + 1])
                /*
                if (i >= kCORE_MEMORY_SIZE) {
                    draw_rect(x, y, size, size, "rgba(0,0,0,0.5)")
                }
                */
            }

            draw_translate_to(0, 0)
        }

        function draw_memory_dump(x, y, w, data, highlight) {
            draw_rect(x, y, w, row_height * data.length, kBlack)

            draw_rect(x, y + highlight * row_height, w, row_height, kDarkGrey)

            for (var i = 0; i < data.length; i++) {
                draw_text(x, y + i * row_height, data[i], (i == highlight) ? kWhite : kSilver)
            }

            return row_height * data.length
        }

        function draw_frame(x, y, w, h, color) {
            h -= 1
            w -= 1
            draw_symbol(x, y, 128, color)
            draw_symbol(x + w * row_height, y, 130, color)
            draw_symbol(x + w * row_height, y + h * row_height, 133, color)
            draw_symbol(x, y + h * row_height, 131, color)

            for (var dx = 1; dx < w; dx++) {
                draw_symbol(x + dx * row_height, y, 129, color)
                draw_symbol(x + dx * row_height, y + h * row_height, 132, color)
            }

            for (var dy = 1; dy < h; dy++) {
                var ddy = y + dy * row_height
                draw_symbol(x, ddy, 134, color)
                draw_symbol(x + w * row_height, ddy, 135, color)
            }
        }

        function draw_button(x, y, w, text, text_color, border_color) {
            if (text_color === undefined) { text_color = kWhite }
            if (border_color === undefined) { border_color = kGrey }
            
            draw_frame(x, y, w, 3, border_color)
            
            draw_text(x + row_height * (w - text.length) / 2, y + row_height, text, text_color)

            var rect = {x1: x, y1: y, x2: x + w * row_height, y2: y + 3 * row_height}

            return rect
        }

        function draw_checkbox(x, y, text, checked) {
            draw_frame(x, y, 3, 3, kGrey)
            
            // check mark
            draw_symbol(x + row_height, y + row_height, checked ? 149 : 32, kWhite)
            
            // title
            draw_text(x + 4 * row_height, y + row_height, text, kWhite)
            
            const w = text.length + 4
            const rect = {x1: x, y1: y, x2: x + w * row_height, y2: y + 3 * row_height}

            return rect
        }

        function draw(redraw) {
            const start = performance.now()

            if (redraw === undefined) {
                redraw = false
            }

            const canvas = document.getElementById("display")

            if (canvas.width != canvas.clientWidth || canvas.height != canvas.clientHeight || redraw) {
                canvas.width = canvas.clientWidth
                canvas.height = canvas.clientHeight
                memory = []
                
                draw_set_context(canvas, scale)
                // draw_rect(0, 0, canvas.width, canvas.height, kBlack)
            }

            var width = Math.floor(canvas.width / scale / row_height) * row_height
            var height = Math.floor(canvas.height / scale / row_height) * row_height
            
            var dump_width = kMAX_ADDRESS_WIDTH + 5 + 2 * (1 + kMAX_ADDRESS_WIDTH)

            var dx = row_height * dump_width
            var dy = 0
            
            draw_rect(0, 0, dx, height - 3 * row_height, kBlack);

            for (var pid = 0; pid < 2; pid++) {
                const next = core.processes[pid].next()
                draw_text(0, dy, `PROCESS ${pid}`, process_colors[pid + 1])

                dy += row_height
                dy += row_height + draw_memory_dump(0, dy, dx, core.memory_dump(next - 10, next + 10), 10)

                const n = core.processes[pid].instruction_pointers.length
                title = `${n} THREAD${n == 1 ? '' : 'S'}: `
                draw_text(0, dy, title, kWhite)

                var tids = core.processes[pid].instruction_pointers.slice(0)
                var w_avail = 25 - title.length
                var px = title.length

                while (tids.length) {
                    s = tids.shift() + (tids.length ? ' ' : '')

                    if (w_avail >= s.length) {
                        w_avail -= s.length
                    }
                    else {
                        px = 0
                        w_avail = 25 - s.length
                        dy += row_height
                    }
                    
                    draw_text(px * row_height, dy, s, kWhite)
                    px += s.length
                }

                dy += row_height * 2
            }

            var c = process_colors[core.current_process_index + 1]
            draw_text(0, dy, `NEXT ${core.next_instruction().to_string()}`, c)
            dy += row_height
            draw_text(0, dy, `CYCLE ${core.cycle}`, kWhite)

            // graphical representation of the memory
            draw_memory(dx, 0, width - dx, height - 3 * row_height)

            // ui buttons
            var by = height - 3 * row_height
            
            draw_rect(0, by, width, 3 * row_height, kDarkestGrey)

            buttons = []
            var b

            b = draw_button(0, by, 10, 'STEP')
            b.doit = run_cycle
            buttons.push(b)

            b = draw_button(11 * row_height, by, 10, 'RUN')
            b.doit = run
            buttons.push(b)

            b = draw_button(22 * row_height, by, 10, 'STOP')
            b.doit = stop
            buttons.push(b)

            b = draw_button(33 * row_height, by, 5, '-')
            b.doit = function() { set_size(-1) }
            buttons.push(b)

            b = draw_button(39 * row_height, by, 5, '+')
            b.doit = function() { set_size(+1) }
            buttons.push(b)
            
            b = draw_checkbox(45 * row_height, by, 'BOOST', (cycles > 1))
            b.doit = function() { toggle_boost(); draw() }
            buttons.push(b)
            
            // UI handler

            canvas.onclick = function(e) {
                var x = e.clientX / scale
                var y = e.clientY / scale
                
                for (var b = 0; b < buttons.length; b++) {
                    const btn = buttons[b]

                    if ((x >= btn.x1) && (y >= btn.y1) && (btn.x2 >= x) && (btn.y2 >= y)) {
                        btn.doit();
                        return;
                    }
                }
            }

            draw_flip()

            const elapsed = Math.floor(100 * (performance.now() - start)) / 100
            document.title = elapsed + "ms " + (redraw ? " full" : "partial")
        }

        function init_everything() {
            core = new Core()

            var code0 =
`
 jmp 0
`

            var code1 =
`
; imp
imp mov 0 next
next dat 0 0
`

            var code2 =
                `
; dwarf
 org jump
 add #4, 3
 mov 2, @2
JUMP jmp -2
dummy dat #42 #0
`

            var code3 =
`
; stone
 mov <2, 3
 add 3, -1
 jmp -2
 dat #0 #0
 dat #-5084, #5084
 DAT 0 0
 MOV 0 0
 ADD 0 0
 NOP 0 0
 JMP 0 0
 SPL 0 0
 SUB 0 0
 JMZ 0 0
 JMN 0 0
 CMP 0 0
 SLT 0 0
 DJN 0 0
 NOP 0 0
`
            var code4 =
`
; mice
        org     start
ptr     dat     #0,  #0
start   mov     #12,  ptr
loop    mov     @ptr,  <copy
        djn     loop,  ptr
        spl     @copy,  0
        add     #653,  copy
        jmz     start,  ptr
copy    dat     #0,  #833
`

            // init both prpgrams
            var p1 = new Program(code1)
            core.load_program(p1, 0, 2000)

            var p2 = new Program(code4)
            core.load_program(p2, 1, 0)

            draw(true)
        }

        function set_size(diff) {
            scale = Math.max(0.5, scale + diff / 2)
            draw(true)
        }

    </script>

</head>

<body onload="init_everything()" onresize="draw()">
    <canvas id="display"></canvas>
</body>

</html>