<html>

<head>
    <meta charset="utf-8" />
    <style>
        * {
            color: #f0f0f0;
            border: 0;
        }

        input {
            background: #202020;
            padding: 8px;
            height: 32px;
        }

        #instruction {
            background: 101010;
            color: greenyellow;
        }

        #memory0,
        #memory1 {
            background: #202020;
        }

        .A {
            color: #f06020;
        }

        .B {
            color: #2080f0;
        }

        .O {
            color: #808080;
        }

        body {
            display: flex;
            margin: 0;
            padding: 0;
        }

        #right {
            white-space: pre-wrap;
            white-space: -moz-pre-wrap;
            white-space: -pre-wrap;
            white-space: -o-pre-wrap;
            word-wrap: break-word;
            display: inline-block;
        }

        #left {
            width: 28ch;
            float: left;
            background: #101010;
        }

        #memory-raw {
            color: white;
        }

        #right {
            width: calc(100% - 28ch);
            float: left;
            background: #202020;
        }

        #toolbar {
            position: absolute;
            bottom: 0;
            height: 32px;
            width: 100%;
            background: #404040;
        }

        #display {
            width: 100%;
            height: 100%;
        }
    </style>

    <script src="rc-core.js"></script>
    <script src="rc-math.js"></script>
    <script src="rc-constants.js"></script>
    <script src="rc-address-modes.js"></script>
    <script src="rc-preprocessor.js"></script>
    <script src="rc-assembler.js"></script>
    <script src="rc-classes.js"></script>
    <script src="rc-instruction.js"></script>
    <script src="rc-instruction-set.js"></script>

    <script src="canvas-font.js"></script>

    <script>

        var core
        var timer
        var buttons
        var scale = 1.5
        var cycles = 1

        function run() {
            stop()
            timer = setInterval(run_cycle, 20)
        }

        function stop() {
            clearInterval(timer)
        }

        function run_cycle() {
            for (var c = 0; c < cycles; c++) {
                if (!core.step()) {
                    stop();
                    break;
                }
            }

            draw()
        }

        function toggle_boost() {
            cycles = cycles == 1 ? 1000 : 1
        }        

        var memory = new Array(kCORE_MEMORY_SIZE)

        const process_colors = ["#222222", "#f06020", "#2080f0"]
        const process_colors_low = ["#222222", "#a04020", "#2060b0"]
        const process_text_colors = ["#808080", "#ffc080", "#80e0ff"]

        function hash(instruction) {
            return `${instruction.opcode}${instruction.read_flag}${instruction.write_flag}${instruction.execution_flag}${instruction.a.mode}${instruction.a.value}${instruction.b.mode}${instruction.b.value}`
        }

        function draw_memory(ctx, dx, dy, w, h) {
            const optimize = false

            function location(index) {
                return { x: index % cols, y: Math.floor(index / cols) }
            }

            const size = row_height
            const cols = Math.floor(w / size)
            const rows = Math.floor(h / size)

            ctx.translate(dx, dy)

            const numEntries = cols * rows

            for (var i = 0; i < numEntries; i++) {
                const idx = i % kCORE_MEMORY_SIZE
                const instruction = core.ram.memory[idx]
                const i_hash = hash(instruction)

                if (i >= kCORE_MEMORY_SIZE && optimize) {
                    break;
                }

                if (i_hash == memory[i]) {
                    continue;
                }

                memory[i] = i_hash

                var l = location(i)
                const x = l.x * size
                const y = l.y * size

                ctx.fillStyle = process_colors_low[instruction.read_flag + 1]
                ctx.beginPath()
                ctx.moveTo(x, y)
                ctx.lineTo(x + size, y)
                ctx.lineTo(x, y + size)
                ctx.fill()

                ctx.fillStyle = process_colors_low[instruction.write_flag + 1]
                ctx.beginPath()
                ctx.moveTo(x + size, y)
                ctx.lineTo(x + size, y + size)
                ctx.lineTo(x, y + size)
                ctx.fill()
                
                const symbol = {
                    'MOV': 0, 'DAT': 1, 'JMP': 2, 'NOP': 3, 'SPL': 4, 
                    'ADD': 5, 'SUB': 6, 'JMZ': 7, 'JNZ': 8, 'CMP': 9,
                    'DJN': 10,
                }[instruction.op.name]

                ctx.fillStyle = process_text_colors[instruction.execution_flag + 1]
                draw_symbol(ctx, x, y, symbol)

                if (i >= kCORE_MEMORY_SIZE) {
                    ctx.fillStyle = "rgba(0,0,0,0.5)"
                    ctx.fillRect(x, y, size, size)
                }
            }

            ctx.translate(-dx, -dy)
        }

        function draw_memory_dump(ctx, x, y, w, data, highlight) {
            ctx.fillStyle = "#000000"
            ctx.fillRect(x, y, w, row_height * data.length)

            ctx.fillStyle = "#404040"
            ctx.fillRect(x, y + highlight * row_height, w, row_height)

            for (var i = 0; i < data.length; i++) {
                ctx.fillStyle = (i == highlight) ? "#ffffff" : "#bbbbbb"
                draw_text(ctx, x, y + i * row_height, data[i])
            }

            return row_height * data.length
        }

        function draw_frame(ctx, x, y, w, h) {
            h -= 1
            w -= 1
            draw_symbol(ctx, x, y, 128)
            draw_symbol(ctx, x + w * row_height, y, 130)
            draw_symbol(ctx, x + w * row_height, y + h * row_height, 133)
            draw_symbol(ctx, x, y + h * row_height, 131)

            for (var dx = 1; dx < w; dx++) {
                draw_symbol(ctx, x + dx * row_height, y, 129)
                draw_symbol(ctx, x + dx * row_height, y + h * row_height, 132)
            }

            for (var dy = 1; dy < h; dy++) {
                var ddy = y + dy * row_height
                draw_symbol(ctx, x, ddy, 134)
                draw_symbol(ctx, x + w * row_height, ddy, 135)
            }
        }

        function draw_button(ctx, x, y, w, text, text_color, border_color) {
            if (text_color === undefined) { text_color = '#ffffff' }
            if (border_color === undefined) { border_color = '#808080' }
            
            ctx.fillStyle = border_color
            draw_frame(ctx, x, y, w, 3)
            
            ctx.fillStyle = text_color
            draw_text(ctx, x + row_height * (w - text.length) / 2, y + row_height, text)

            var rect = {x1: x * scale, y1: y * scale, x2: x + w * row_height, y2: y + 3 * row_height}
            rect.x2 *= scale
            rect.y2 *= scale

            return rect
        }

        function draw_checkbox(ctx, x, y, text, checked) {
            ctx.fillStyle = "#808080"
            draw_frame(ctx, x, y, 3, 3)
            
            // check mark
            ctx.fillStyle = "#ffffff"
            draw_symbol(ctx, x + row_height, y + row_height, checked ? 149 : 32)
            
            // title
            draw_text(ctx, x + 4 * row_height, y + row_height, text)
            
            const w = text.length + 4
            const rect = {x1: x * scale, y1: y * scale, x2: x + w * row_height, y2: y + 3 * row_height}
            rect.x2 *= scale
            rect.y2 *= scale

            return rect
        }

        function draw(redraw) {
            if (redraw === undefined) {
                redraw = false
            }

            const canvas = document.getElementById("display")
            const ctx = canvas.getContext("2d")

            if (canvas.width != canvas.clientWidth || canvas.height != canvas.clientHeight || redraw) {
                canvas.width = canvas.clientWidth
                canvas.height = canvas.clientHeight
                memory = []

                ctx.fillStyle = "#000000"
                ctx.fillRect(0, 0, canvas.width, canvas.height);
            }

            ctx.scale(scale, scale)

            var width = canvas.width / scale
            var height = canvas.height / scale
            
            var dump_width = kMAX_ADDRESS_WIDTH + 5 + 2 * (1 + kMAX_ADDRESS_WIDTH)

            var dx = row_height * dump_width
            var dy = 0
            
            ctx.fillStyle = "#000000"
            ctx.fillRect(0, 0, dx, height - 3 * row_height);

            for (var pid = 0; pid < 2; pid++) {
                const next = core.processes[pid].next()
                ctx.fillStyle = process_colors[pid + 1]
                draw_text(ctx, 0, dy, `PROCESS ${pid}`)

                dy += row_height
                dy += row_height + draw_memory_dump(ctx, 0, dy, dx, core.memory_dump(next - 10, next + 10), 10)

                const n = core.processes[pid].instruction_pointers.length
                title = `${n} THREAD${n == 1 ? '' : 'S'}: `
                draw_text(ctx, 0, dy, title)

                var tids = core.processes[pid].instruction_pointers.slice(0)
                var w_avail = 25 - title.length
                var px = title.length

                while (tids.length) {
                    s = tids.shift() + (tids.length ? ' ' : '')

                    if (w_avail >= s.length) {
                        w_avail -= s.length
                    }
                    else {
                        px = 0
                        w_avail = 25 - s.length
                        dy += row_height
                    }
                    
                    draw_text(ctx, px * row_height, dy, s)
                    px += s.length
                }

                dy += row_height * 2
            }

            ctx.fillStyle = process_colors[core.current_process_index + 1]
            draw_text(ctx, 0, dy, `NEXT ${core.next_instruction().to_string()}`)
            dy += row_height
            draw_text(ctx, 0, dy, `CYCLE ${core.cycle}`)

            // graphical representation of the memory
            draw_memory(ctx, dx, 0, width - dx, height - 3 * row_height)

            // ui buttons
            var by = height - 3 * row_height
            
            ctx.fillStyle = "#202020"
            ctx.fillRect(0, by, width, 3 * row_height)

            buttons = []
            var b

            b = draw_button(ctx, 0, by, 10, 'STEP')
            b.doit = run_cycle
            buttons.push(b)

            b = draw_button(ctx, 11 * row_height, by, 10, 'RUN')
            b.doit = run
            buttons.push(b)

            b = draw_button(ctx, 22 * row_height, by, 10, 'STOP')
            b.doit = stop
            buttons.push(b)

            b = draw_button(ctx, 33 * row_height, by, 5, '-')
            b.doit = function() { set_size(-1) }
            buttons.push(b)

            b = draw_button(ctx, 39 * row_height, by, 5, '+')
            b.doit = function() { set_size(+1) }
            buttons.push(b)
            
            b = draw_checkbox(ctx, 45 * row_height, by, 'BOOST', (cycles > 1))
            b.doit = function() { toggle_boost(); draw() }
            buttons.push(b)
            
            ctx.scale(1 / scale, 1 / scale)

            // UI handler

            canvas.onclick = function(e) {
                var x = e.clientX
                var y = e.clientY

                for (var b = 0; b < buttons.length; b++) {
                    const btn = buttons[b]

                    if ((x >= btn.x1) && (y >= btn.y1) && (btn.x2 >= x) && (btn.y2 >= y)) {
                        btn.doit();
                        return;
                    }
                }
            }

        }

        function init_everything() {
            core = new Core()

            var code0 =
`
 jmp 0
`

            var code1 =
`
; imp
imp mov 0 next
next dat 0 0
`

            var code2 =
                `
; dwarf
 org jump
 add #4, 3
 mov 2, @2
JUMP jmp -2
dummy dat #42 #0
`

            var code3 =
`
; stone
 mov <2, 3
 add 3, -1
 jmp -2
 dat #0 #0
 dat #-5084, #5084
 DAT 0 0
 MOV 0 0
 ADD 0 0
 NOP 0 0
 JMP 0 0
 SPL 0 0
 SUB 0 0
 JMZ 0 0
 JMN 0 0
 CMP 0 0
 SLT 0 0
 DJN 0 0
 NOP 0 0
`
            var code4 =
`
; mice
        org     start
ptr     dat     #0,  #0
start   mov     #12,  ptr
loop    mov     @ptr,  <copy
        djn     loop,  ptr
        spl     @copy,  0
        add     #653,  copy
        jmz     start,  ptr
copy    dat     #0,  #833
`

            // init both prpgrams
            var p1 = new Program(code1)
            core.load_program(p1, 0, 2000)

            var p2 = new Program(code4)
            core.load_program(p2, 1, 0)

            draw()
        }

        function set_size(diff) {
            scale = Math.max(0.5, scale + diff / 2)
            draw(true)
        }

    </script>

</head>

<body onload="init_everything()" onresize="draw()">
    <canvas id="display"></canvas>
    <!--
    <div id="toolbar">
        <input type=button value="step" onclick="run_cycle()">
        <input type=button value="dump" onclick="dump_state()">
        <input type=button value="run" onclick="run()">
        <input type=button value="stop" onclick="stop()">
        <input type=button value="-" onclick="set_size(-1)">
        <input type=button value="+" onclick="set_size(+1)">
    </div>
    -->
</body>

</html>