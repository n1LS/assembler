<html>

<head>
    <meta charset="utf-8" />
    <style>
        * {
            background: black;
            border: 0px;
            margin: 0px;
            padding: 0px;
        }

        #display {
            width: 100%;
            height: 100%;
            background: black;
        }
    </style>

    <script src="rc-core.js"></script>
    <script src="rc-math.js"></script>
    <script src="rc-constants.js"></script>
    <script src="rc-address-modes.js"></script>
    <script src="rc-preprocessor.js"></script>
    <script src="rc-assembler.js"></script>
    <script src="rc-classes.js"></script>
    <script src="rc-instruction.js"></script>
    <script src="rc-instruction-set.js"></script>

    <script src="canvas-draw.js"></script>
    <script src="canvas-font.js"></script>

    <script>
        var core
        var timer
        var buttons
        var scale = 1.5
        var cycles = 1

        function run() {
            stop()
            timer = setInterval(run_cycle, 20)
        }

        function stop() {
            clearInterval(timer)
        }

        function run_cycle() {
            for (var c = 0; c < cycles; c++) {
                if (!core.step()) {
                    stop();
                    break;
                }
            }

            draw()
        }

        function toggle_boost() {
            cycles = cycles == 1 ? 1000 : 1
        }

        var memory = new Array(kCORE_MEMORY_SIZE)

        const process_colors = [kDarkestGrey, kProcess1, kProcess2]
        const process_colors_low = [kDarkestGrey, kProcessLow1, kProcessLow2]
        const process_text_colors = [kGrey, kProcess1Text, kProcess2Text]

        function hash(instruction) {
            return `${instruction.opcode}${instruction.read_flag}${instruction.write_flag}${instruction.execution_flag}${instruction.a.mode}${instruction.a.value}${instruction.b.mode}${instruction.b.value}`
        }

        function draw_memory_1x1(w, h) {
            for (var i = 0; i < w * h; i++) {
                const idx = i % kCORE_MEMORY_SIZE
                const instruction = core.ram.memory[idx]
                var color = kDarkGrey

                if (instruction.execution_flag != -1) {
                    color = process_colors[instruction.execution_flag + 1]
                } else if (instruction.write_flag != -1) {
                    color = process_colors[instruction.execution_flag + 1]
                }

                if (i >= kCORE_MEMORY_SIZE) {
                    color = draw_darken(color)
                }

                x = i % w
                y = ~~(i / w)

                draw_pixel(x, y, color)
            }
        }

        function draw_memory_medium(w, h, size) {
            const cols = ~~(w / size)
            const rows = ~~(h / size)

            function location(index) {
                return {
                    x: index % cols,
                    y: ~~(index / cols)
                }
            }

            for (var i = 0; i < cols * rows; i++) {
                const idx = i % kCORE_MEMORY_SIZE
                const instruction = core.ram.memory[idx]
                var c1 = process_colors_low[instruction.write_flag + 1]
                var c2 = process_colors_low[instruction.read_flag + 1]
                var c3 = process_colors[instruction.execution_flag + 1]
                const l = location(i)

                const x = l.x * size
                const y = l.y * size

                if (i != idx) {
                    c1 = draw_darken(c1)
                    c2 = draw_darken(c2)
                    c3 = draw_darken(c3)
                }

                draw_triangles(x, y, size, size, c2, c1)
                draw_rect(x + 1, y + 1, size - 2, size - 2, c3)
            }
        }


        function draw_memory_big(w, h, num_visible) {
            const size = row_height
            const cols = ~~(w / size)

            function location(index) {
                return {
                    x: index % cols,
                    y: ~~(index / cols)
                }
            }

            for (var i = 0; i < num_visible; i++) {
                const idx = i % kCORE_MEMORY_SIZE
                const instruction = core.ram.memory[idx]
                const i_hash = hash(instruction)

                if (i_hash == memory[i]) {
                    continue;
                }

                memory[i] = i_hash

                var l = location(i)
                const x = l.x * size
                const y = l.y * size

                var color1 = process_colors_low[instruction.read_flag + 1]
                var color2 = process_colors_low[instruction.write_flag + 1]

                if (i >= kCORE_MEMORY_SIZE) {
                    color1 = draw_darken(color1)
                    color2 = draw_darken(color2)
                }

                draw_triangles(x, y, size, size, color1, color2)

                const symbol = {
                    'MOV': 0,
                    'DAT': 1,
                    'JMP': 2,
                    'NOP': 3,
                    'SPL': 4,
                    'ADD': 5,
                    'SUB': 6,
                    'JMZ': 7,
                    'JNZ': 8,
                    'CMP': 9,
                    'DJN': 10,
                }[instruction.op.name]

                var color = process_text_colors[instruction.execution_flag + 1]

                if (i >= kCORE_MEMORY_SIZE) {
                    color = draw_darken(color)
                }

                draw_symbol(x, y, symbol, color)
            }
        }

        function draw_memory(dx, dy, w, h) {
            const size = row_height
            const cols = ~~(w / size)
            const rows = ~~(h / size)

            draw_translate_to(dx, dy)

            const num_visible = cols * rows

            if (num_visible < kCORE_MEMORY_SIZE) {
                // usable sizes are 5x5 / 3x3 / 1x1
                const sizes = [7, 6, 5, 4, 3, 1]

                for (var s = 0; s < sizes.length; s++) {
                    const sz = sizes[s]

                    if ((~~(w / sz) * ~~(h / sz)) >= kCORE_MEMORY_SIZE) {
                        if (sz == 1) {
                            draw_memory_1x1(w, h)
                        } else {
                            draw_memory_medium(w, h, sz)
                        }

                        break;
                    }
                }
            } else {
                draw_memory_big(w, h, num_visible)
            }

            draw_translate_to(0, 0)
        }

        function draw_memory_dump(x, y, w, data, highlight) {
            draw_rect(x, y, w, row_height * data.length, kBlack)

            draw_rect(x, y + highlight * row_height, w, row_height, kDarkGrey)

            for (var i = 0; i < data.length; i++) {
                draw_text(x, y + i * row_height, data[i], (i == highlight) ? kWhite : kSilver)
            }

            return row_height * data.length
        }

        function draw_frame(x, y, w, h, color) {
            h -= 1
            w -= 1
            draw_symbol(x, y, 128, color)
            draw_symbol(x + w * row_height, y, 130, color)
            draw_symbol(x + w * row_height, y + h * row_height, 133, color)
            draw_symbol(x, y + h * row_height, 131, color)

            for (var dx = 1; dx < w; dx++) {
                draw_symbol(x + dx * row_height, y, 129, color)
                draw_symbol(x + dx * row_height, y + h * row_height, 132, color)
            }

            for (var dy = 1; dy < h; dy++) {
                var ddy = y + dy * row_height
                draw_symbol(x, ddy, 134, color)
                draw_symbol(x + w * row_height, ddy, 135, color)
            }
        }

        function draw_button(x, y, text, text_color, border_color) {
            if (text_color === undefined) {
                text_color = kWhite
            }
            if (border_color === undefined) {
                border_color = kGrey
            }

            const w = text.length + 2

            draw_frame(x, y, w, 3, border_color)

            draw_text(x + row_height, y + row_height, text, text_color)

            var rect = {
                x1: x,
                y1: y,
                x2: x + w * row_height,
                y2: y + 3 * row_height,
                width: w * row_height
            }

            return rect
        }

        function draw_checkbox(x, y, text, checked) {
            draw_frame(x, y, 3, 3, kGrey)

            // check mark
            draw_symbol(x + row_height, y + row_height, checked ? 149 : 32, kWhite)

            // title
            draw_text(x + 4 * row_height, y + row_height, text, kWhite)

            const w = text.length + 4
            const rect = {
                x1: x,
                y1: y,
                x2: x + w * row_height,
                y2: y + 3 * row_height,
                width: w * row_height
            }

            return rect
        }

        function draw(redraw) {
            const start = performance.now()

            if (redraw === undefined) {
                redraw = false
            }

            const canvas = document.getElementById("display")

            if (canvas.width != canvas.clientWidth || canvas.height != canvas.clientHeight || redraw) {
                canvas.width = canvas.clientWidth
                canvas.height = canvas.clientHeight
                memory = []

                draw_set_context(canvas, scale)
            }

            var width = ~~(canvas.width / scale / row_height) * row_height
            var height = ~~(canvas.height / scale / row_height) * row_height

            var dump_width = kMAX_ADDRESS_WIDTH + 5 + 2 * (1 + kMAX_ADDRESS_WIDTH)

            var dx = row_height * dump_width
            var dy = 0

            draw_rect(0, 0, dx, height - 3 * row_height, kBlack);

            // TODO: use number of lines according to the thingie
            const total_rows = ~~(canvas.height / scale / row_height)
            const usable_rows = total_rows - 2 * 4 /* title, space, threads, space */ - 1 /* spacer */ - 2 /* next, cycle */ -
                2 * 1 /* current instruction */ - 3 /* bottom menu */
            const look_behind = ~~(usable_rows / 4)
            const look_ahead = Math.ceil(usable_rows / 4)

            for (var pid = 0; pid < core.processes.length; pid++) {
                const next = core.processes[pid].next()
                draw_text(0, dy, `PROCESS ${pid}`, process_colors[pid + 1])

                dy += row_height
                dy += row_height + draw_memory_dump(0, dy, dx, core.memory_dump(next - look_behind, next + look_ahead),
                    look_behind)

                const n = core.processes[pid].instruction_pointers.length
                title = `${n} THREAD${n == 1 ? '' : 'S'}: `
                draw_text(0, dy, title, kWhite)

                var tids = core.processes[pid].instruction_pointers.slice(0)
                var s = tids.join(' ')

                const available = 22 - title.length

                if (s.length > available) {
                    s = s.substr(0, available - 1) + String.fromCharCode(31)
                } else {
                    s = s.substr(0, available)
                }
                draw_text(title.length * row_height, dy, s, kWhite)

                dy += row_height * 2
            }

            var c = process_colors[core.current_process_index + 1]
            const ni = core.next_instruction();

            if (ni !== undefined) {
                draw_text(0, dy, `NEXT ${ni.to_string()}`, c)
            }

            dy += row_height
            draw_text(0, dy, `CYCLE ${core.cycle}`, kWhite)

            // graphical representation of the memory
            draw_memory(dx, 0, width - dx, height - 3 * row_height)

            // ui buttons
            var by = height - 3 * row_height

            draw_rect(0, by, width, 3 * row_height, kDarkestGrey)

            buttons = []
            var b
            var bx = 0

            b = draw_button(bx, by, String.fromCharCode(28))
            bx += b.width + row_height
            b.doit = run_cycle
            buttons.push(b)

            b = draw_button(bx, by, String.fromCharCode(30))
            bx += b.width + row_height
            b.doit = run
            buttons.push(b)

            b = draw_button(bx, by, String.fromCharCode(15))
            bx += b.width + row_height
            b.doit = stop
            buttons.push(b)

            b = draw_button(bx, by, '-')
            bx += b.width
            b.doit = function () {
                set_size(-1)
            }
            buttons.push(b)

            b = draw_button(bx, by, '+')
            bx += b.width + row_height
            b.doit = function () {
                set_size(+1)
            }
            buttons.push(b)

            b = draw_checkbox(bx, by, 'BOOST', (cycles > 1))
            bx += b.width + row_height
            b.doit = function () {
                toggle_boost();
                draw()
            }
            buttons.push(b)

            // UI handler

            canvas.onclick = function (e) {
                var x = e.clientX / scale
                var y = e.clientY / scale

                for (var b = 0; b < buttons.length; b++) {
                    const btn = buttons[b]

                    if ((x >= btn.x1) && (y >= btn.y1) && (btn.x2 >= x) && (btn.y2 >= y)) {
                        btn.doit();
                        return;
                    }
                }
            }

            draw_flip()

            const elapsed = ~~(100 * (performance.now() - start)) / 100
            document.title = elapsed + "ms " + (redraw ? "full" : "part")
        }

        function init_everything() {
            core = new Core()

            var code0 =
                `
 jmp 0
`

            var code1 =
                `
; imp
imp mov 0 next
next dat 0 0
`

            var code_dwarf =
                `
; dwarf
    org     jump
    add     #4, 3
    mov     2,  @2
JUMP jmp    -2
dummy dat   #42 #0
`

            var code_stone =
                `
; stone
    mov     <2, 3
    add     3,  -1
    jmp     -2
    dat     #0  #0
    dat     #-5084, #5084
    DAT     0   0
    MOV     0   0
    ADD     0   0
    NOP     0   0
    JMP     0   0
    SPL     0   0
    SUB     0   0
    JMZ     0   0
    JMN     0   0
    CMP     0   0
    SLT     0   0
    DJN     0   0
    NOP     0   0
`
            var code_mice =
                `
; mice
        org start
ptr     dat     #0     ,  #0
start   mov     #12    ,  ptr
loop    mov     @ptr   ,  <copy
        djn     loop   ,  ptr
        spl     @copy  ,  0
        add     #653   ,  copy
        jmz     start  ,  ptr
copy    dat     #0     ,  #827
`

            var test_code =
                `
start   CMP #0, 1
        DAT #1, #0 
        CMP 4, 5
        CMP 4, 5
        DAT #1, #1
        JMP start
        DAT #0, #2
        DAT #2, #2
        DAT #2, #2
`
            // init both prpgrams
            var p1 = new Program(code_mice)
            core.load_program(p1, 2000)
/*
            var p2 = new Program(code_mice)
            core.load_program(p2, 0)
*/
            draw(true)
        }

        function set_size(diff) {
            scale = Math.max(1.0, scale + diff / 4)
            draw(true)
        }

        document.onkeydown = function (event) {
            event = event || window.event;
            
            switch (event.keyCode) {
                case 83: 
                    run_cycle();
                    break;
            }
        };
    </script>

</head>

<body onload="init_everything()" onresize="draw()">
    <canvas id="display"></canvas>
</body>

</html>