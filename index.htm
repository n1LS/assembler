<html>

<head>
        <meta charset="utf-8"/>
        <link href="https://fonts.googleapis.com/css?family=Overpass+Mono" rel="stylesheet">
        <link href="https://www.schickt.de/fonts/icon.css" rel="stylesheet">
        <style>
        * {
            color: #f0f0f0;
            border: 0;
            font-weight: lighter;
            font-family: 'Overpass Mono', monospace;
            font-size: 11px;
            line-height: 90%;
        }

        input {
            background: #202020;
            padding: 8px;
            height: 32px;
        }

        #instruction {
            background: 101010;
            color: greenyellow;
        }

        #memory0,
        #memory1 {
            background: #202020;
        }

        .A {
            color: #f06020;
        }

        .B {
            color: #2080f0;
        }

        .O {
            color: #808080;
        }

        body {
            display: flex;
            margin: 0;
            padding: 0;
        }

        #right {
            white-space: pre-wrap;
            white-space: -moz-pre-wrap;
            white-space: -pre-wrap;
            white-space: -o-pre-wrap;
            word-wrap: break-word;
            display: inline-block;
        }

        #left {
            width: 28ch;
            float: left;
            background: #101010;
        }

        #memory-raw {
            color: white;
        }

        #right {
            width: calc(100% - 28ch);
            float: left;
            background: #202020;
        }

        #toolbar {
            position: absolute;
            bottom: 0;
            height: 32px;
            width: 100%;
            background: #404040;
        }

        #display {
            width: 100%;
            height: calc(100% - 64px);
        }
    </style>

    <script src="rc-core.js"></script>
    <script src="rc-math.js"></script>
    <script src="rc-constants.js"></script>
    <script src="rc-address-modes.js"></script>
    <script src="rc-preprocessor.js"></script>
    <script src="rc-assembler.js"></script>
    <script src="rc-classes.js"></script>
    <script src="rc-instruction.js"></script>
    <script src="rc-instruction-set.js"></script>
    <script>

        var core

        var timer
        
        function run() {
            stop()
            timer = setInterval(run_cycle, 20)
        }
        
        function stop() {
            clearInterval(timer)
        }
        
        function run_cycle() {
            core.step()
            update()
        }
        
        function dump_state() {
            const pid = core.current_process_index
            const next = core.current_process().next()
            var dump = core.memory_dump(next - 5, next + 25).join("<br>")
            document.getElementById("memory" + pid).innerHTML = "PROCESS " + pid + "\n\n" + dump
        }

        var memory = new Array(kCORE_MEMORY_SIZE)

        function draw() {
            const canvas = document.getElementById("display")

            if (canvas.width != canvas.clientWidth || canvas.height != canvas.clientHeight) {
                canvas.width = canvas.clientWidth
                canvas.height = canvas.clientHeight
                memory = []
            }

            const spacing = 0

            const ctx = canvas.getContext("2d")
            
            const size = Math.floor(Math.sqrt((canvas.clientHeight * canvas.clientWidth) / kCORE_MEMORY_SIZE) - spacing)
            const cols = Math.floor(canvas.clientWidth / size)
            const rows = Math.floor(canvas.clientHeight / size)
            
            console.log("size = " + cols + ":" + rows)
            function hash(instruction) {
                return `${instruction.opcode}${instruction.read_flag}${instruction.write_flag}${instruction.execution_flag}${instruction.a.mode}${instruction.a.value}${instruction.b.mode}${instruction.b.value}`
            }

            function location(index) {
                return { x: index % cols, y: Math.floor(index / cols) }
            }

            ctx.scale(size, size)

            const numEntries = cols * rows

            for (var i = 0; i < numEntries; i++)  {
                const idx = i % kCORE_MEMORY_SIZE
                const instruction = core.ram.memory[idx]
                const i_hash = hash(instruction)

                if (i_hash == memory[i]) {
                    continue;
                }
                
                memory[i] = i_hash

                var l = location(i)
                const x = l.x
                const y = l.y


                ctx.fillStyle = ["#333333","#f06020", "#2080f0"][instruction.read_flag + 1]
                ctx.beginPath()
                ctx.moveTo(x, y)
                ctx.lineTo(x + 1, y)
                ctx.lineTo(x, y + 1)
                ctx.fill()
                
                ctx.fillStyle = ["#333333","#f06020", "#2080f0"][0] // instruction.write_flag + 1]
                ctx.beginPath()
                ctx.moveTo(x + 1, y)
                ctx.lineTo(x + 1, y + 1)
                ctx.lineTo(x, y + 1)
                ctx.fill()

                var op = Opcode.from_code(instruction.opcode).name
                
                const A =  [0.2,0.2]
                const B =  [0.5,0.2]
                const C =  [0.8,0.2]
                const D =  [0.2,0.5]
                const E =  [0.5,0.5]
                const F =  [0.8,0.5]
                const G =  [0.2,0.8]
                const H =  [0.5,0.8]
                const I =  [0.8,0.8]
                const J =  [0.3,0.3]
                const K =  [0.7,0.3]
                const L =  [0.3,0.7]
                const M =  [0.7,0.7]
                const N =  [0.5,0.35]
                const O =  [0.65,0.5]
                const P =  [0.5,0.65]
                const Q =  [0.35,0.5]
                
                const symbols = {
                    'DAT': [A,B,K,F,M,H,G,A],
                    'MOV': [G,A,E,C,I],
                    'ADD': [G,B,I,O,Q],
                    'NOP': [G,A,I,C],
                    'JMP': [C,F,M,H,G],
                    'FRK': [G,D,E,D,A,C],
                    'SUB': [C,A,D,F,I,G],
                    'JMZ': [K,F,M,F,E,H,G,A,B,E],
                    'JMN': [A,B,H,G,A,B,G,H,E,F,K,F,M,F],
                    'CMP': [C,B,J,D,L,H,I],
                    'SLT': [A,I,F,I,H],
                    'DJN': [A,G,H,I,E],
                }

                ctx.strokeStyle = ["#606060","#ffc080", "#80e0ff"][instruction.execution_flag + 1]
                ctx.lineWidth = 0.1
                ctx.lineCap = "round"
                const pts = symbols[op]

                ctx.beginPath()
                ctx.moveTo(x + pts[0][0], y + pts[0][1])

                for (var p = 1; p < pts.length; p++) {
                    pt = pts[p];
                    ctx.lineTo(x + pt[0], y + pt[1]);
                }

                ctx.stroke()
                


                // ctx.fillText(characters[op], x + 1, y + 1 - 2);

                if (i >= kCORE_MEMORY_SIZE) {
                    ctx.fillStyle = "rgba(0,0,0,0.5)"
                    ctx.fillRect(x, y, 1, 1)
                }
            }
            
            ctx.scale(1 / size, 1 / size)
        }

        function init_everything() {
            core = new Core()
            
            var code1 =
                "; imp\n" +
                "imp mov 0 next\n" +
                "next dat 0 0";

            var code2 =
                "; dwarf\n" +
                " add #4, 3\n" +
                " mov 2, @2\n" +
                " jmp -2\n" +
                "dummy dat #42 #0";

            var code3 = 
                "; stone \n" +
                " mov <2, 3\n" + 
                " add 3, -1\n" + 
                " jmp -2\n" + 
                " dat #0 #0\n" + 
                " dat #-5084, #5084" + 
                " DAT 0 0\n" +
                " MOV 0 0\n" +
                " ADD 0 0\n" +
                " NOP 0 0\n" +
                " JMP 0 0\n" +
                " FRK 0 0\n" +
                " SUB 0 0\n" +
                " JMZ 0 0\n" +
                " JMN 0 0\n" +
                " CMP 0 0\n" +
                " SLT 0 0\n" +
                " DJN 0 0\n" +
                " NOP 0 0\n"

            // init both prpgrams
            
            var p1 = new Program(code2)
            core.load_program(p1, 0, 2000)

            var p2 = new Program(code3)
            core.load_program(p2, 1, 0)

            update()
        }

        function update() {
            dump_state()

            document.getElementById("instruction").innerHTML = "NEXT   " + core.next_instruction().to_string()

            var processes = core.processes
            var proc = processes.length + " process(es)<br><br>"

            for (var p = 0; p < processes.length; p++) {
                proc += `Process ${p}:<br>` + processes[p].instruction_pointers.join("<br>") + "<br>"
            }

            document.getElementById("processes").innerHTML = proc;

            draw()
        }

    </script>

</head>

<body onload="init_everything()" onresize="draw()">
    <div id="left">
        <pre id="instruction">no instruction</pre>
        <pre id="memory0">no memory dump</pre>
        <pre id="memory1">no memory dump</pre>
        <pre id="processes">no process info</pre>
    </div>
    <div id="right">
        <canvas id="display" width="512" height="512"></canvas>
    </div>
    <div id="toolbar">
        <input type=button value="step" onclick="run_cycle()">
        <input type=button value="dump" onclick="dump_state()">
        <input type=button value="run" onclick="run()">
        <input type=button value="stop" onclick="stop()">
    </div>

</body>

</html>