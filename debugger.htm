<html>

<head>
    <meta charset="utf-8" />
    <style>
        * {
            background: black;
            border: 0px;
            margin: 0px;
            padding: 0px;
        }

        #display {
            width: 100%;
            height: 100%;
            background: black;
        }
    </style>

    <script src="rc-core.js"></script>
    <script src="rc-math.js"></script>
    <script src="rc-address-modes.js"></script>
    <script src="rc-preprocessor.js"></script>
    <script src="rc-assembler.js"></script>
    <script src="rc-classes.js"></script>
    <script src="rc-instruction.js"></script>
    <script src="rc-instruction-set.js"></script>

    <script src="canvas-draw.js"></script>
    <script src="canvas-font.js"></script>

    <script>
        var environment = new Environment()
        var core
        var timer
        var buttons
        var scale = 1
        var cycles = 1

        function run() {
            stop()
            timer = setInterval(run_cycle, 20)
        }

        function stop() {
            clearInterval(timer)
        }

        function run_cycle() {
            for (var c = 0; c < cycles; c++) {
                if (!core.step()) {
                    stop();
                    break;
                }
            }

            draw()
        }

        function toggle_boost() {
            cycles = cycles == 1 ? 1000 : 1
        }

        var memory = new Array(environment.core_size)

        function hash(instruction) {
            return `${instruction.opcode}${instruction.read_flag}${instruction.write_flag}${instruction.execution_flag}${instruction.a.mode}${instruction.a.value}${instruction.b.mode}${instruction.b.value}`
        }

        function draw_memory_1x1(w, h) {
            for (var i = 0; i < w * h; i++) {
                const idx = i % core.environment.core_size
                const instruction = core.ram.memory[idx]
                var color = kDarkGrey

                if (instruction.execution_flag != -1) {
                    color = process_colors[0][instruction.execution_flag + 1]
                } else if (instruction.write_flag != -1) {
                    color = process_colors[0][instruction.execution_flag + 1]
                }

                if (i >= core.environment.core_size) {
                    color = draw_darken(color)
                }

                x = i % w
                y = ~~(i / w)

                draw_pixel(x, y, color)
            }
        }

        function draw_memory_medium(w, h, size) {
            const cols = ~~(w / size)
            const rows = ~~(h / size)

            function location(index) {
                return {
                    x: index % cols,
                    y: ~~(index / cols)
                }
            }

            for (var i = 0; i < cols * rows; i++) {
                const idx = i % core.environment.core_size
                const instruction = core.ram.memory[idx]
                var c1 = process_colors[1][instruction.write_flag + 1]
                var c2 = process_colors[1][instruction.read_flag + 1]
                var c3 = process_colors[1][instruction.execution_flag + 1]
                const l = location(i)

                const x = l.x * size
                const y = l.y * size

                if (i != idx) {
                    c1 = draw_darken(c1)
                    c2 = draw_darken(c2)
                    c3 = draw_darken(c3)
                }

                draw_triangles(x, y, size, size, c2, c1)
                draw_rect(x + 1, y + 1, size - 2, size - 2, c3)
            }
        }


        function draw_memory_big(w, h, num_visible) {
            const size = row_height
            const cols = ~~(w / size)

            function location(index) {
                return {
                    x: index % cols,
                    y: ~~(index / cols)
                }
            }

            for (var i = 0; i < num_visible; i++) {
                const idx = i % core.environment.core_size
                const instruction = core.ram.memory[idx]
                const i_hash = hash(instruction)

                if (i_hash == memory[i]) {
                    continue;
                }

                memory[i] = i_hash

                var l = location(i)
                const x = l.x * size
                const y = l.y * size

                var color1 = process_colors[2][instruction.read_flag + 1]
                var color2 = process_colors[2][instruction.write_flag + 1]

                if (i >= core.environment.core_size) {
                    color1 = draw_darken(color1)
                    color2 = draw_darken(color2)
                }

                draw_triangles(x, y, size, size, color1, color2)

                const symbol = {
                    'MOV': 0,
                    'DAT': 1,
                    'JMP': 2,
                    'NOP': 3,
                    'SPL': 4,
                    'ADD': 5,
                    'SUB': 6,
                    'JMZ': 7,
                    'JNZ': 8,
                    'CMP': 9,
                    'DJN': 10,
                }[instruction.op.name]

                var color = process_colors[0][instruction.execution_flag + 1]

                if (i >= core.environment.core_size) {
                    color = draw_darken(color)
                }

                draw_symbol(x, y, symbol, color)
            }
        }

        function draw_memory(dx, dy, w, h) {
            const size = row_height
            const cols = ~~(w / size)
            const rows = ~~(h / size)

            draw_translate_to(dx, dy)

            const num_visible = cols * rows

            if (num_visible < core.environment.core_size) {
                // usable sizes are 5x5 / 3x3 / 1x1
                const sizes = [7, 6, 5, 4, 3, 1]

                for (var s = 0; s < sizes.length; s++) {
                    const sz = sizes[s]

                    if ((~~(w/sz) * ~~(h/sz)) >= core.environment.core_size) {
                        if (sz == 1) {
                            draw_memory_1x1(w, h)
                        } else {
                            draw_memory_medium(w, h, sz)
                        }

                        break;
                    }
                }
            } else {
                draw_memory_big(w, h, num_visible)
            }

            draw_translate_to(0, 0)
        }

        function draw_memory_dump(x, y, w, data, highlight) {
            draw_rect(x, y, w, row_height * data.length, kBlack)

            draw_rect(x, y + highlight * row_height, w, row_height, kDarkGrey)

            for (var i = 0; i < data.length; i++) {
                draw_text(x, y + i * row_height, data[i], (i == highlight) ? kWhite : kSilver)
            }

            return row_height * data.length
        }

        function draw_frame(x, y, w, h, color) {
            h -= 1
            w -= 1
            draw_symbol(x, y, 128, color)
            draw_symbol(x + w * row_height, y, 130, color)
            draw_symbol(x + w * row_height, y + h * row_height, 133, color)
            draw_symbol(x, y + h * row_height, 131, color)

            for (var dx = 1; dx < w; dx++) {
                draw_symbol(x + dx * row_height, y, 129, color)
                draw_symbol(x + dx * row_height, y + h * row_height, 132, color)
            }

            for (var dy = 1; dy < h; dy++) {
                var ddy = y + dy * row_height
                draw_symbol(x, ddy, 134, color)
                draw_symbol(x + w * row_height, ddy, 135, color)
            }
        }

        function draw_button(x, y, text, text_color, border_color) {
            if (text_color === undefined) {
                text_color = kWhite
            }
            if (border_color === undefined) {
                border_color = kGrey
            }

            const w = text.length + 2

            draw_frame(x, y, w, 3, border_color)

            draw_text(x + row_height, y + row_height, text, text_color)

            var rect = {
                x1: x,
                y1: y,
                x2: x + w * row_height,
                y2: y + 3 * row_height,
                width: w * row_height
            }

            return rect
        }

        function draw_checkbox(x, y, text, checked) {
            draw_frame(x, y, 3, 3, kGrey)

            // check mark
            draw_symbol(x + row_height, y + row_height, checked ? 149 : 32, kWhite)

            // title
            draw_text(x + 4 * row_height, y + row_height, text, kWhite)

            const w = text.length + 4
            const rect = {
                x1: x,
                y1: y,
                x2: x + w * row_height,
                y2: y + 3 * row_height,
                width: w * row_height
            }

            return rect
        }

        function draw(redraw) {
            const start = performance.now()

            if (redraw === undefined) {
                redraw = false
            }

            const canvas = document.getElementById("display")

            if (canvas.width != canvas.clientWidth || canvas.height != canvas.clientHeight || redraw) {
                canvas.width = canvas.clientWidth
                canvas.height = canvas.clientHeight
                memory = []

                draw_set_context(canvas, scale)
            }

            var width = ~~(canvas.width / scale / row_height) * row_height
            var height = ~~(canvas.height / scale / row_height) * row_height

            const max_width = 2 + ('' + (core.environment.core_size - 1)).length
            var dump_width = 4 + 3 * max_width

            var dx = row_height * dump_width
            var dy = 0

            draw_rect(0, 0, dx, height - 3 * row_height, kBlack);

            // TODO: use number of lines according to the thingie
            const total_rows = ~~(canvas.height / scale / row_height)
            const usable_rows = total_rows - 8 //\n,next,cycle,\n,toolbar
            const rows_per_process = ~~(usable_rows / core.processes.length)
            const memory_rows = rows_per_process - 2 /* title, spaver */
            const look_behind = ~~(memory_rows / 4)
            const look_ahead = memory_rows - 1 - look_behind

            for (var pid = 0; pid < core.processes.length; pid++) {
                const next = core.processes[pid].next()
                const name = core.processes[pid].program.metadata.get('name')
                draw_text(0, dy, `#${pid} ${name}`, process_colors[1][pid + 1])

                dy += row_height
                dy += row_height + draw_memory_dump(0, dy, dx, core.memory_dump(next - look_behind, next + look_ahead), look_behind)

                const n = core.processes[pid].instruction_pointers.length
                title = `${n} THREAD${n == 1 ? '' : 'S'}: `
                draw_text(0, dy, title, kWhite)

                var tids = core.processes[pid].instruction_pointers.slice(0)
                var s = tids.join(' ')

                const available = 22 - title.length

                if (s.length > available) {
                    s = s.substr(0, available - 1) + String.fromCharCode(31)
                } else {
                    s = s.substr(0, available)
                }
                draw_text(title.length * row_height, dy, s, kWhite)

                dy += row_height * 2
            }

            var c = process_colors[1][core.current_process_index + 1]
            const ni = core.next_instruction();

            if (ni !== null) {
                draw_text(0, dy, `NEXT ${ni.to_string(max_width - 1)}`, c)
            }

            dy += row_height
            draw_text(0, dy, `CYCLE ${core.cycle}`, kWhite)

            // graphical representation of the memory
            draw_memory(dx, 0, width - dx, height - 3 * row_height)

            // ui buttons
            var by = height - 3 * row_height

            draw_rect(0, by, width, 3 * row_height, kDarkestGrey)

            buttons = []
            var b
            var bx = 0

            b = draw_button(bx, by, String.fromCharCode(28))
            bx += b.width + row_height
            b.doit = run_cycle
            buttons.push(b)

            b = draw_button(bx, by, String.fromCharCode(30))
            bx += b.width + row_height
            b.doit = run
            buttons.push(b)

            b = draw_button(bx, by, String.fromCharCode(15))
            bx += b.width + row_height
            b.doit = stop
            buttons.push(b)

            b = draw_button(bx, by, '-')
            bx += b.width
            b.doit = function () {
                set_size(-1)
            }
            buttons.push(b)

            b = draw_button(bx, by, '+')
            bx += b.width + row_height
            b.doit = function () {
                set_size(+1)
            }
            buttons.push(b)

            b = draw_checkbox(bx, by, 'BOOST', (cycles > 1))
            bx += b.width + row_height
            b.doit = function () {
                toggle_boost();
                draw()
            }
            buttons.push(b)

            // UI handler

            canvas.onclick = function (e) {
                var x = e.clientX / scale
                var y = e.clientY / scale

                for (var b = 0; b < buttons.length; b++) {
                    const btn = buttons[b]

                    if ((x >= btn.x1) && (y >= btn.y1) && (btn.x2 >= x) && (btn.y2 >= y)) {
                        btn.doit();
                        return;
                    }
                }
            }

            draw_flip()

            const elapsed = ~~(100 * (performance.now() - start)) / 100
            document.title = elapsed + "ms " + (redraw ? "full" : "part")
        }

        function init_everything() {
            core = new Core(environment)

            var code0 =
                `
;name idle                
 jmp 0
`

            var code_imp =
                `
;name imp
imp mov 0 next
next dat 0 0
`

            var code_dwarf =
                `
;name dwarf
    org     jump
    add     #4, 3
    mov     2,  @2
JUMP jmp    -2
dummy dat   #42 #0
`

            var code_stone =
                `
;name stone
    mov     <2, 3
    add     3,  -1
    jmp     -2
    dat     #0  #0
    dat     #-5084, #5084
    DAT     0   0
    MOV     0   0
    ADD     0   0
    NOP     0   0
    JMP     0   0
    SPL     0   0
    SUB     0   0
    JMZ     0   0
    JMN     0   0
    CMP     0   0
    SLT     0   0
    DJN     0   0
    NOP     0   0
`
            var code_mice =
                `
;name mice
        org start
ptr     dat     #0     ,  #0
start   mov     #12    ,  ptr
loop    mov     @ptr   ,  <copy
        djn     loop   ,  ptr
        spl     @copy  ,  0
        add     #653   ,  copy
        jmz     start  ,  ptr
copy    dat     #0     ,  #833
`

            var test_code =
                `
start   CMP #0, 1
        DAT #1, #0 
        CMP 4, 5
        CMP 4, 5
        DAT #1, #1
        JMP start
        DAT #0, #2
        DAT #2, #2
        DAT #2, #2
`

            var code_validate = `
;redcode
;name Validate 1.1R
;author Stefan Strack
;strategy System validation program - based on Mark Durham's validation suite
;
;   This program tests your corewar system for compliance with the ICWS88-
;   standard and compatibility with KotH. It self-ties (i.e. loops forever)
;   if the running system is ICWS88-compliant and uses in-register evaluation;
;   suicides (terminates) if the interpreter is not ICWS compliant and/or uses
;   in-memory evaluation. A counter at label 'flag' can be used to determine
;   where the exception occured.
;
;   Tests:
;   -all opcodes and addressing modes
;   -ICWS88-style ADD/SUB
;   -ICWS88-style SPL
;   -correct timing
;   -in-memory vs. in-register evaluation
;   -core initialization
;
;   Version 1.1: added autodestruct in case process gets stuck


;assert MAXLENGTH >= 90

start   spl l1,count+1
        jmz <start,0
count   djn count,#36      ;time cycles
        sub #1,@start
clear   mov t1,<last+2     ;autodestruct if stuck
        jmp clear
t1      dat #0,#1
t2      dat #0,#3
l1      spl l2
        dat <t2,<t2
l2      cmp t1,t2
        jmp fail
        spl l4
        jmz l3,<0
t3      dat #0,#1
t4      dat #0,#2
l3      jmp @0,<0
l4      jmp <t5,#0
        jmp l5
t5      dat #0,#0
t6      dat #0,#-1
l5      cmp t3,t4
        jmp fail
        cmp t5,t6
        jmp fail
        jmp <t7,<t7
        jmp l6
t7      dat #0,#0
t8      dat #0,#-2
l6      cmp t7,t8
        jmp fail
        mov t9,<t9         ;test in-memory evaluation
t9      jmn l7,1
t10     jmn l7+1,1
l7      cmp t9,t10
        jmp fail
        mov @0,<t11
t11     jmn l8,1
t12     jmn l8+1,1
l8      cmp t11,t12
        jmp fail
        spl l9
        mov <t13,t14
t13     dat <0,#1
t14     dat <0,#1
t15     dat <0,#-1
l9      mov <t16,t16
t16     jmz l10,1
        jmp fail
l10     cmp t13,t15
        jmp fail
        add t17,<t17
t17     jmp 1,1
t18     jmp 2,1
        cmp t17,t18
        jmp fail
        add @0,<t19
t19     jmp 1,1
        jmp fail
        cmp t18,t19
        jmp fail
        spl l11            ;ICWS86 SPL will fail here
        cmp t20,t21
        jmp l12
        jmp fail
l11     sub <t20,t20
t20     dat #2,#1
t21     dat #0,#0
l12     cmp t20,t21
        jmp fail
t22     sub <t23,<t23
t23     jmp l13,1
t24     sub <-2,<1
t25     jmp l13+2,-1
l13     cmp t22,t24
        jmp fail
        cmp t23,t25
        jmp fail
        cmp start-1,t26    ;Core initialization dat 0,0
        jmp l14
        jmp fail
t26     dat #0,#0
l14     slt #0,count       ;check cycle timer
        jmp success
fail    mov count,flag     ;save counter for post-mortem debugging
	mov t1,count       ;kill counter
	jmp clear          ;and auto-destruct
flag    dat #0
success mov flag,clear     ;cancel autodestruct
last    jmp 0              ;and loop forever

        end start
`
            // init both prpgrams
            core.load_program(new Program(code_imp, core.environment))
            core.load_program(new Program(code_imp, core.environment))

            draw(true)

            // listen to messages from parent window
            window.addEventListener('message', message_handler, false)
        }

        function set_size(diff) {
            scale = Math.max(1.0, scale + diff / 2)
            draw(true)
        }

        document.onkeydown = function (event) {
            event = event || window.event;

            switch (event.keyCode) {
                case 'S'.charCodeAt(0):
                    run_cycle();
                    break;
                case 'D'.charCodeAt(0):
                    for (var i = 0; i < 10; i++) run_cycle();
                    break;
            }
        };

        function message_handler(event) {
            items = event.data.split('::')
            action = items.shift(0)

            switch (action) {
                case 'launch':
                    load(items)
                    break
    
                case 'environment':
                    core = new Core(JSON.parse(atob(items[0])))
                    draw(true)
                    break
            }
        }

        function load(warriors) {
            core.reset()

            warriors.forEach(base64 => {
                code = atob(base64)
                core.load_program(new Program(code, core.environment))
            })

            draw(1)
        }

    </script>

</head>

<body onload="init_everything()" onresize="draw()">
    <canvas id="display"></canvas>
</body>

</html>